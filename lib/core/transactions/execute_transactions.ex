defmodule Core.Transactions.ExecuteTransactions do
  @moduledoc """
  Transactions module
  """

  @window_time_in_seconds 120

  alias Model.Transaction
  alias Model.Account
  alias Core.Authorizer.Utils.ValueObject
  alias Renders.Account, as: RendersAccount

  def execute(account, transactions) do
    now = DateTime.utc_now()

    with {:ok, account} <- ValueObject.cast_and_apply(account, Account),
         {:ok, account} <- check_if_has_initialized_account(account),
         {:ok, account} <- check_account_has_active_card(account),
         {:ok, transactions} <- apply_changes_in_transactions(transactions),
         {:ok, result} <- process_transactions(account, transactions, now) do
      RendersAccount.render(result.account_movements_log)
    else
      {:error, %Ecto.Changeset{valid?: false}} ->
        %{"account" => %{"violations" => ["account-not-initialized"]}}

      {:error, _} = error ->
        error
    end
  end

  defp check_if_has_initialized_account(%Account{} = account), do: {:ok, account}

  defp check_account_has_active_card(%Account{active_card: true} = account),
    do: {:ok, account}

  defp check_account_has_active_card(%Account{active_card: false} = account),
    do: {:error, %{account | violations: ["card-not-active"]}}

  defp apply_changes_in_transactions(transactions) do
    {:ok,
     transactions
     |> Enum.map(&ValueObject.cast_and_apply(&1, Transaction))
     |> Enum.filter(&match?({:ok, _}, &1))
     |> Enum.map(&elem(&1, 1))}
  end

  defp process_transactions(account, transactions, now) do
    result =
      account
      |> process_settlements_with_time_window(transactions, now)
      |> process_settlements()

    {:ok, result}
  end

  defp process_settlements_with_time_window(account, transactions, now) do
    %{account_movements_log: [account], transactions: transactions, transactions_log: []}
    |> check_high_frequency_small_interval(now)
  end

  defp check_high_frequency_small_interval(data, now) do
    time_ago = now |> DateTime.add(-@window_time_in_seconds, :second)
    transactions = data.transactions

    transactions
    |> Enum.with_index()
    |> Enum.reduce(data, fn
      {transaction, index}, history ->
        [account | _] = accounts_movements = history.account_movements_log

        processed_transactions = history.transactions_log

        case {
          is_inside_delay?(time_ago, now, transaction.time),
          check_limit(account, transaction)
        } do
          {true, %Account{violations: []} = account} when index <= 2 ->
            Map.merge(history, %{
              account_movements_log: [account | accounts_movements],
              transactions_log: [
                %{transaction | is_processed: true} | processed_transactions
              ]
            })

          {true, %Account{violations: violations} = account} ->
            Map.merge(
              history,
              %{
                account_movements_log: [
                  Map.merge(
                    account,
                    %{
                      violations: ["high_frequency_small_interval" | violations],
                      available_limit: account.available_limit + transaction.amount
                    }
                  )
                  | accounts_movements
                ],
                transactions_log: [
                  %{transaction | rejected: true}
                  | processed_transactions
                ]
              }
            )

          {false, _} ->
            Map.merge(
              history,
              %{
                transactions_log: [
                  transaction
                  | processed_transactions
                ]
              }
            )
        end
    end)
  end

  # defp check_doubled_transaction(data, now) do
  #   time_ago = now |> DateTime.add(-@window_time_in_seconds, :second)
  #   account_movement_log = data.account_movements_log
  #   transactions_log = data.transactions_log
  #   processed_transactions = []

  #   transaction_info_log_in_last_time = get_merchant_and_amount(transactions_log, now)
  #   # |> IO.inspect(label: :transaction_info_log_in_last_time)

  #   transactions_log
  #   |> Enum.reduce_while(data, fn transaction, history ->
  #     [account | _] = history.account_movements_log

  #     # IO.inspect(
  #     #   {is_inside_delay?(time_ago, now, transaction.time), check_limit(account, transaction),
  #     #    Map.get(
  #     #      transaction_info_log_in_last_time,
  #     #      "#{transaction.merchant}#{transaction.amount}",
  #     #      []
  #     #    )}
  #     # )

  #     case {
  #       is_inside_delay?(time_ago, now, transaction.time),
  #       check_limit(account, transaction),
  #       Map.get(
  #         transaction_info_log_in_last_time,
  #         "#{transaction.merchant}#{transaction.amount}",
  #         []
  #       )
  #     } do
  #       {true, %Account{violations: []} = account, []} ->
  #         {:cont,
  #          Map.merge(history, %{
  #            account_movements_log: [account | account_movement_log],
  #            transactions_log: [
  #              %{transaction | is_processed: true} | processed_transactions
  #            ]
  #          })}

  #       {true, %Account{violations: violations} = account, [_ | _]} ->
  #         account_movement = %{
  #           account
  #           | is_processed: true,
  #             violations: ["doubled-transaction" | violations]
  #         }

  #         {:cont,
  #          Map.merge(history, %{
  #            account_movements_log: [account_movement | account_movement_log],
  #            transactions_log: [
  #              %{transaction | is_processed: true} | processed_transactions
  #            ]
  #          })}

  #       {false, _, _} ->
  #         {:cont,
  #          Map.merge(history, %{
  #            account_movements_log: account_movement_log,
  #            transactions_log: [
  #              %{transaction | is_processed: true} | processed_transactions
  #            ]
  #          })}
  #     end
  #   end)
  # end

  defp check_limit(
         %Account{available_limit: available_limit, violations: violations} = account,
         %Transaction{
           amount: amount
         }
       )
       when amount > available_limit,
       do: %{account | violations: ["insufficient-limit" | violations]}

  defp check_limit(%Account{available_limit: available_limit} = account, %Transaction{
         amount: amount
       })
       when amount <= available_limit,
       do: %{account | available_limit: available_limit - amount}

  defp is_inside_delay?(time_ago, now, transaction_time) do
    time_ago = DateTime.truncate(time_ago, :millisecond)
    now = DateTime.truncate(now, :millisecond)
    transaction_time = DateTime.truncate(transaction_time, :millisecond)

    bigger_or_equal =
      DateTime.compare(time_ago, transaction_time) == :eq or
        DateTime.compare(time_ago, transaction_time) == :gt

    less_than = DateTime.compare(transaction_time, now) == :lt

    if bigger_or_equal and less_than do
      true
    else
      false
    end
  end

  defp get_merchant_and_amount(transactions, now) do
    time_ago = now |> DateTime.add(-@window_time_in_seconds, :second)

    transactions
    |> Enum.reduce_while([], fn transaction, transaction_info_log ->
      if is_inside_delay?(time_ago, now, transaction.time) do
        {:cont, [transaction | transaction_info_log]}
      else
        {:cont, transaction_info_log}
      end
    end)
    |> Enum.group_by(&"#{&1.merchant}/#{&1.amount}")
  end

  defp process_settlements(data) do
    account_movement_log = data.account_movements_log

    data.transactions_log
    |> Enum.reduce(data, fn transaction, history ->
      [account | _] = account_movement_log
      processed_transactions = history.transactions_log

      case {transaction.is_processed, transaction.rejected, check_limit(account, transaction)} do
        {true, false, _} ->
          history

        {false, false, %Account{violations: [_ | _]} = account} ->
          Map.merge(
            history,
            %{
              account_movements_log: [%{account | violations: []} | account_movement_log],
              transactions_log: [
                %{transaction | is_processed: true} | processed_transactions
              ]
            }
          )

        {false, true, %Account{violations: [_ | _]}} ->
          history
      end
    end)
  end
end
