
  
  
  

# Authorizer

  

A CLI written in Elixir that authorizes transactions for a specific account after a

  

series of predefined rules.
  

  

## Features

  

  

1. Account's creation

  

2. Transaction's authorization

  

3. Read lines from Stdin

  

4. Account's rendering

  

  

## Setup

  

  

Local Setup

  

  

-  ```$ make setup```

  

  

#### Docker Compose

  

  

Assuming you already have Docker and Docker Compose installed, run the command below.

  

  

-  ```$ make build_container```

  

  

## Testes

  

  

Tests can be be executed:

  

  

Local:

  

  

-  ```$ mix test```

  

  

Docker:

  

-  ```$ docker-compose run app mix test```

  

  

You can see test coverage using the following command:
  

  

Local:

  

  

-  ```$ mix coveralls```

  

  

Docker:

  

  

-  ```$ docker-compose run app mix coveralls```

  

  

## Gerando o authorizer bin

  

Local:

  

- The instructions below will generate a file called `"authorizer"`;

  

-  ```$ make authorizer_cli```

  

  

Docker:

  

The`"authorizer"` is already automatically generated inside the container after the build.

  

  

## Execução

  

Local:

  

-  ``` $ ./authorizer < {file}.json```

  

  

Docker:

  

-  ``` $ docker-compose run app authorizer < {file}.json```

  

  

**Obs:**

  

You can use the `"operations_sample.json"` file for a first test case.

  

  

## Organização dos módulos

  

The arch image can be viewed locally by accessing path assets/images/arch.png)

  

**Obs:**

  
The image can be viewed locally by accessing the file assets/images/arch.png (For reasons of anonymity I didn't add a link)
  

1. **Cli.Scripts.Authorizer**: Creates a collection of data (strings) read from stdin through the **Cli.Ports.Stdin** module;

  

- **Cli.Ports.Stdin** a clear implementation of a content of [Hexagonal architecture](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)), which is that of Port-Adapters

  

- This module calls an implementation of an adapter **Cli.Adapters.Stdin** which is called outside the test context;

  

- Otherwise, it calls the implementation of a mock to simulate the input of stdin in the integration tests.


  

2. **Cli.Scripts.Authorizer** performs a json-to-Map decode of each entry in the collection generated by **Cli.Ports.Stdin**;

  

3. **Cli.Readers.AuhtorizerReader** performs processing according to the structure of the collection. Cases covered are account creation and transaction authorization;

  

4. Each case will call an appropriate module (**Core.Transactions.AuthorizeTransactions** for transaction authorization or **Core.Accounts.CreateAccount** for account creation), each process contains a public function **.execute( )**;

  

5. Each .execute called will be a process that will run in parallel with the other executes;

  

6. The **Core.Transactions.AuthorizeTransactions** module calls an auxiliary module defined below:

  

	- **Core.Transactions.Policies.TimeWindow**: is the module responsible for applying time window validation policies on transactions. (high-frequency-small-interval and doubled-transaction), the **Core.Ledger** is also called here;
- **Core.Ledger**: Performs the settlement of each transaction (check card limit)

  

7. The **Core.Transactions.AuthorizeTransactions** returns the account transactions that will be the input of the **Cli.Renders.Account.render()** thus generating the CLI output.
  

## External libs

  

- [Jason](https://github.com/michalmuskala/jason) -> decode from json to map;

  

- [Ecto](https://hexdocs.pm/ecto/Ecto.html) -> creation of account and transaction memory models, which can be extended to database model in the future;

  

- [Mox](https://github.com/dashbitco/mox) -> Creation of mocks for stdin;

  

- [Credo](https://github.com/rrrene/credo) -> Code static code analysis;

  

- [Dialyzer](https://github.com/jeremyjh/dialyxir) -> Code static code analysis.
  

  

## Note on some technical decisions

  ![Model_ER](https://github.com/gabrielangelo/authorizer/blob/master/assets/images/arch.png)

- Using the programming language erlang/elixir to use [BEAM](https://blog.erlang.org/a-brief-BEAM-primer/) in a financial application.

  

- It is an [umbrella](https://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-projects.html#umbrella-projects) application that manages 2 applications:

  

- Core: The core of the application's business rule, it contains the account and transaction models as well as the authorizer routines;

  

- Cli: The application responsible for reading stdin data and creating the correct entries for the Core application's business rules functions;

  

- Both applications talk to each other.

  

- Arch was designed to be basically a "map-reduce" of entries that are scheduled to different processes that run concurrently. The output ( Accounts ) is a "reduce" of the outputs of each process. Function used: [Task.async_stream/3](https://hexdocs.pm/elixir/1.12/Task.html#async_stream/3)

- Each Core.Transactions.AuthorizeTransactions instance is a batch operation that performs a list of transactions for a given account. That is, a process is scheduled for each account and its operations (Be it transaction authorization or account creation)

- Generation of a **binary** that encapsulates all built software. It's more flexible for environments that don't have elixir installed. Also, you can add it to the /bin directory and use it from any other operating system dir.

- Each authorizer is a "pipeline" that shares a structure defined below:

```elixir

Core.Types.AuthorizeTransactionsHistory{

account_movements_log: list(),

transactions: list(),

transactions_log: list(),

settled_transactions_count: integer()

}```

  

- `"account_movements_log"`: is the list of bank movements performed by each transaction. The status of each move with its violations is saved here;

  

- `"transactions"`: it is the list of transactions, here there is no state change, it is only used for a primary parsing;

  

- `"transactions_log"`: is the list of processed transactions, this list is incremented when a transaction is settled or rejected;

  

- `"settled_transactions_count"`: settled transactions counter, used to count transactions in time window policy apply.

  
  

**Additional Note**

Thinking about some extreme cases, I created another branch that tries to deal with some cases that I judged to be corner-cases, as an input of transactions from different days/years where the authorizer should deal with each set of transactions of a period chronologically applying the same rules:

  

```json

# input

["{\"account\": {\"active-card\": true, \"available-limit\": 100}}\n",

"{\"transaction\": {\"merchant\": \"Burger King\", \"amount\": 20, \"time\": \"2019-02-13T11:00:00.000Z\"}}\n",

"{\"transaction\": {\"merchant\": \"Habbib's\", \"amount\": 20, \"time\": \"2019-02-13T11:00:01.000Z\"}}\n",

"{\"transaction\": {\"merchant\": \"McDonald's\", \"amount\": 20, \"time\": \"2019-02-13T11:01:01.000Z\"}}\n",

"{\"transaction\": {\"merchant\": \"Subway\", \"amount\": 20, \"time\": \"2019-02-13T11:01:31.000Z\"}}\n",

"{\"transaction\": {\"merchant\": \"Burger King\", \"amount\": 10, \"time\": \"2019-02-13T12:00:00.000Z\"}}",

"{\"transaction\": {\"merchant\": \"Burger King\", \"amount\": 190, \"time\": \"2021-09-26 03:08:13.449719Z\"}}\n",

"{\"transaction\": {\"merchant\": \"Burger King\", \"amount\": 5, \"time\": \"2021-09-26 03:08:13.449719Z\"}}\n",

"{\"transaction\": {\"merchant\": \"Burger King\", \"amount\": 150, \"time\": \"2021-09-26 03:08:13.449719Z\"}}\n",

"{\"transaction\": {\"merchant\": \"Burger King\", \"amount\": 190, \"time\": \"2021-09-26 03:08:13.449719Z\"}}\n"]

  

# output

"{\"account\":{\"active-card\":true,\"available-limit\":100,\"violations\":[]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":80,\"violations\":[]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":60,\"violations\":[]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":40,\"violations\":[]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":40,\"violations\":[\"high_frequency_small_interval\"]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":30,\"violations\":[]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":40,\"violations\":[\"insufficient-limit\"]}}",

"{\"account\":{\"active-card\":true,\"available-limit\":35,\"violations\":[\"doubled-transaction\",\"insufficient-limit\"]}}"]```

```

However, to keep the project simple and considering that this is an operation that involves instantaneous liquidations, it may not make sense to support this type of feature at the moment, so I preferred not to merge with the master, leaving it open for future decisions. On the other hand, it would be interesting to deal with this type of context in situations where it is necessary to reprocess old transactions via message bus (a kafka for example). However, at the moment we have a generic model that batch processes transactions of the same day without taking into account the date of receipt of the message.
